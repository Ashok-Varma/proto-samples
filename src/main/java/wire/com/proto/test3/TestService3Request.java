// Code generated by Wire protocol buffer compiler, do not edit.
// Source: test3.TestService3Request in test3.proto
package com.proto.test3;

import com.squareup.wire.AnyMessage;
import com.squareup.wire.EnumAdapter;
import com.squareup.wire.FieldEncoding;
import com.squareup.wire.Message;
import com.squareup.wire.ProtoAdapter;
import com.squareup.wire.ProtoReader;
import com.squareup.wire.ProtoWriter;
import com.squareup.wire.ReverseProtoWriter;
import com.squareup.wire.Syntax;
import com.squareup.wire.WireEnum;
import com.squareup.wire.WireField;
import com.squareup.wire.internal.Internal;
import java.io.IOException;
import java.lang.Boolean;
import java.lang.Double;
import java.lang.Integer;
import java.lang.Long;
import java.lang.Object;
import java.lang.Override;
import java.lang.String;
import java.lang.StringBuilder;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import okio.ByteString;

public final class TestService3Request extends Message<TestService3Request, TestService3Request.Builder> {
  public static final ProtoAdapter<TestService3Request> ADAPTER = new ProtoAdapter_TestService3Request();

  private static final long serialVersionUID = 0L;

  public static final Double DEFAULT_OPTIONALDOUBLE = 0.0d;

  public static final Integer DEFAULT_OPTIONALINT32 = 0;

  public static final Long DEFAULT_OPTIONALINT64 = 0L;

  public static final Integer DEFAULT_OPTIONALUINT32 = 0;

  public static final Long DEFAULT_OPTIONALUINT64 = 0L;

  public static final Integer DEFAULT_OPTIONALSINT32 = 0;

  public static final Long DEFAULT_OPTIONALSINT64 = 0L;

  public static final Integer DEFAULT_OPTIONALFIXED32 = 0;

  public static final Long DEFAULT_OPTIONALFIXED64 = 0L;

  public static final Integer DEFAULT_OPTIONALSFIXED32 = 0;

  public static final Long DEFAULT_OPTIONALSFIXED64 = 0L;

  public static final Boolean DEFAULT_OPTIONALBOOL = false;

  public static final String DEFAULT_OPTIONALSTRING = "";

  public static final ByteString DEFAULT_OPTIONALBYTES = ByteString.EMPTY;

  public static final Corpus DEFAULT_CORPUS = Corpus.UNIVERSAL;

  public static final String DEFAULT_NAME = "";

  /**
   *  Extensions not supported in proto3
   *  https://developers.google.com/protocol-buffers/docs/proto#extensions
   *  https://developers.google.com/protocol-buffers/docs/proto#choosing
   *  extensions 100 to 199, 1000 to max;
   *  https://developers.google.com/protocol-buffers/docs/proto#specifying-rules
   *  https://developers.google.com/protocol-buffers/docs/proto#scalar
   */
  @WireField(
      tag = 1,
      adapter = "com.squareup.wire.ProtoAdapter#DOUBLE"
  )
  public final Double optionalDouble;

  @WireField(
      tag = 3,
      adapter = "com.squareup.wire.ProtoAdapter#DOUBLE",
      label = WireField.Label.OMIT_IDENTITY
  )
  public final double requiredDouble;

  @WireField(
      tag = 4,
      adapter = "com.squareup.wire.ProtoAdapter#INT32"
  )
  public final Integer optionalInt32;

  @WireField(
      tag = 5,
      adapter = "com.squareup.wire.ProtoAdapter#INT32",
      label = WireField.Label.OMIT_IDENTITY
  )
  public final int requiredInt32;

  @WireField(
      tag = 6,
      adapter = "com.squareup.wire.ProtoAdapter#INT64"
  )
  public final Long optionalInt64;

  @WireField(
      tag = 7,
      adapter = "com.squareup.wire.ProtoAdapter#INT64",
      label = WireField.Label.OMIT_IDENTITY
  )
  public final long requiredInt64;

  @WireField(
      tag = 8,
      adapter = "com.squareup.wire.ProtoAdapter#UINT32"
  )
  public final Integer optionalUint32;

  @WireField(
      tag = 12,
      adapter = "com.squareup.wire.ProtoAdapter#UINT32",
      label = WireField.Label.OMIT_IDENTITY
  )
  public final int requiredUint32;

  @WireField(
      tag = 13,
      adapter = "com.squareup.wire.ProtoAdapter#UINT64"
  )
  public final Long optionalUint64;

  @WireField(
      tag = 14,
      adapter = "com.squareup.wire.ProtoAdapter#UINT64",
      label = WireField.Label.OMIT_IDENTITY
  )
  public final long requiredUint64;

  @WireField(
      tag = 16,
      adapter = "com.squareup.wire.ProtoAdapter#SINT32"
  )
  public final Integer optionalSint32;

  @WireField(
      tag = 17,
      adapter = "com.squareup.wire.ProtoAdapter#SINT32",
      label = WireField.Label.OMIT_IDENTITY
  )
  public final int requiredSint32;

  @WireField(
      tag = 18,
      adapter = "com.squareup.wire.ProtoAdapter#SINT64"
  )
  public final Long optionalSint64;

  @WireField(
      tag = 19,
      adapter = "com.squareup.wire.ProtoAdapter#SINT64",
      label = WireField.Label.OMIT_IDENTITY
  )
  public final long requiredSint64;

  @WireField(
      tag = 20,
      adapter = "com.squareup.wire.ProtoAdapter#FIXED32"
  )
  public final Integer optionalFixed32;

  @WireField(
      tag = 21,
      adapter = "com.squareup.wire.ProtoAdapter#FIXED32",
      label = WireField.Label.OMIT_IDENTITY
  )
  public final int requiredFixed32;

  @WireField(
      tag = 22,
      adapter = "com.squareup.wire.ProtoAdapter#FIXED64"
  )
  public final Long optionalFixed64;

  @WireField(
      tag = 23,
      adapter = "com.squareup.wire.ProtoAdapter#FIXED64",
      label = WireField.Label.OMIT_IDENTITY
  )
  public final long requiredFixed64;

  @WireField(
      tag = 24,
      adapter = "com.squareup.wire.ProtoAdapter#SFIXED32"
  )
  public final Integer optionalSfixed32;

  @WireField(
      tag = 25,
      adapter = "com.squareup.wire.ProtoAdapter#SFIXED32",
      label = WireField.Label.OMIT_IDENTITY
  )
  public final int requiredSfixed32;

  @WireField(
      tag = 26,
      adapter = "com.squareup.wire.ProtoAdapter#SFIXED64"
  )
  public final Long optionalSfixed64;

  @WireField(
      tag = 27,
      adapter = "com.squareup.wire.ProtoAdapter#SFIXED64",
      label = WireField.Label.OMIT_IDENTITY
  )
  public final long requiredSfixed64;

  @WireField(
      tag = 28,
      adapter = "com.squareup.wire.ProtoAdapter#BOOL"
  )
  public final Boolean optionalBool;

  @WireField(
      tag = 29,
      adapter = "com.squareup.wire.ProtoAdapter#BOOL",
      label = WireField.Label.OMIT_IDENTITY
  )
  public final boolean requiredBool;

  @WireField(
      tag = 30,
      adapter = "com.squareup.wire.ProtoAdapter#STRING"
  )
  public final String optionalString;

  @WireField(
      tag = 31,
      adapter = "com.squareup.wire.ProtoAdapter#STRING",
      label = WireField.Label.OMIT_IDENTITY
  )
  public final String requiredString;

  @WireField(
      tag = 32,
      adapter = "com.squareup.wire.ProtoAdapter#BYTES"
  )
  public final ByteString optionalBytes;

  @WireField(
      tag = 33,
      adapter = "com.squareup.wire.ProtoAdapter#BYTES",
      label = WireField.Label.OMIT_IDENTITY
  )
  public final ByteString requiredBytes;

  @WireField(
      tag = 36,
      adapter = "com.proto.test3.TestService3Request$Corpus#ADAPTER"
  )
  public final Corpus corpus;

  /**
   *  https://developers.google.com/protocol-buffers/docs/proto#other
   */
  @WireField(
      tag = 37,
      adapter = "com.squareup.wire.ProtoAdapter#INT32",
      label = WireField.Label.PACKED
  )
  public final List<Integer> samples;

  /**
   *  https://developers.google.com/protocol-buffers/docs/proto#maps (MAps can't have lables)
   */
  @WireField(
      tag = 40,
      keyAdapter = "com.squareup.wire.ProtoAdapter#STRING",
      adapter = "com.proto.test3.TestService3Request$NestedMessage#ADAPTER"
  )
  public final Map<String, NestedMessage> map;

  @WireField(
      tag = 41,
      adapter = "com.proto.test3.TestService3Request$MapFieldEntry#ADAPTER",
      label = WireField.Label.REPEATED,
      jsonName = "mapField"
  )
  public final List<MapFieldEntry> map_field;

  /**
   * https://developers.google.com/protocol-buffers/docs/proto3#any (Support to any)
   */
  @WireField(
      tag = 42,
      adapter = "com.squareup.wire.AnyMessage#ADAPTER",
      label = WireField.Label.REPEATED
  )
  public final List<AnyMessage> details;

  @WireField(
      tag = 38,
      adapter = "com.squareup.wire.ProtoAdapter#STRING",
      oneofName = "oneOfField"
  )
  public final String name;

  @WireField(
      tag = 39,
      adapter = "com.proto.test3.TestService3Request$NestedMessage#ADAPTER",
      oneofName = "oneOfField"
  )
  public final NestedMessage nested;

  public TestService3Request(Builder builder, ByteString unknownFields) {
    super(ADAPTER, unknownFields);
    if (Internal.countNonNull(builder.name, builder.nested) > 1) {
      throw new IllegalArgumentException("at most one of builder.name, builder.nested may be non-null");
    }
    this.optionalDouble = builder.optionalDouble;
    this.requiredDouble = builder.requiredDouble;
    this.optionalInt32 = builder.optionalInt32;
    this.requiredInt32 = builder.requiredInt32;
    this.optionalInt64 = builder.optionalInt64;
    this.requiredInt64 = builder.requiredInt64;
    this.optionalUint32 = builder.optionalUint32;
    this.requiredUint32 = builder.requiredUint32;
    this.optionalUint64 = builder.optionalUint64;
    this.requiredUint64 = builder.requiredUint64;
    this.optionalSint32 = builder.optionalSint32;
    this.requiredSint32 = builder.requiredSint32;
    this.optionalSint64 = builder.optionalSint64;
    this.requiredSint64 = builder.requiredSint64;
    this.optionalFixed32 = builder.optionalFixed32;
    this.requiredFixed32 = builder.requiredFixed32;
    this.optionalFixed64 = builder.optionalFixed64;
    this.requiredFixed64 = builder.requiredFixed64;
    this.optionalSfixed32 = builder.optionalSfixed32;
    this.requiredSfixed32 = builder.requiredSfixed32;
    this.optionalSfixed64 = builder.optionalSfixed64;
    this.requiredSfixed64 = builder.requiredSfixed64;
    this.optionalBool = builder.optionalBool;
    this.requiredBool = builder.requiredBool;
    this.optionalString = builder.optionalString;
    if (builder.requiredString == null) {
      throw new IllegalArgumentException("builder.requiredString == null");
    }
    this.requiredString = builder.requiredString;
    this.optionalBytes = builder.optionalBytes;
    if (builder.requiredBytes == null) {
      throw new IllegalArgumentException("builder.requiredBytes == null");
    }
    this.requiredBytes = builder.requiredBytes;
    this.corpus = builder.corpus;
    this.samples = Internal.immutableCopyOf("samples", builder.samples);
    this.map = Internal.immutableCopyOf("map", builder.map);
    this.map_field = Internal.immutableCopyOf("map_field", builder.map_field);
    this.details = Internal.immutableCopyOf("details", builder.details);
    this.name = builder.name;
    this.nested = builder.nested;
  }

  @Override
  public Builder newBuilder() {
    Builder builder = new Builder();
    builder.optionalDouble = optionalDouble;
    builder.requiredDouble = requiredDouble;
    builder.optionalInt32 = optionalInt32;
    builder.requiredInt32 = requiredInt32;
    builder.optionalInt64 = optionalInt64;
    builder.requiredInt64 = requiredInt64;
    builder.optionalUint32 = optionalUint32;
    builder.requiredUint32 = requiredUint32;
    builder.optionalUint64 = optionalUint64;
    builder.requiredUint64 = requiredUint64;
    builder.optionalSint32 = optionalSint32;
    builder.requiredSint32 = requiredSint32;
    builder.optionalSint64 = optionalSint64;
    builder.requiredSint64 = requiredSint64;
    builder.optionalFixed32 = optionalFixed32;
    builder.requiredFixed32 = requiredFixed32;
    builder.optionalFixed64 = optionalFixed64;
    builder.requiredFixed64 = requiredFixed64;
    builder.optionalSfixed32 = optionalSfixed32;
    builder.requiredSfixed32 = requiredSfixed32;
    builder.optionalSfixed64 = optionalSfixed64;
    builder.requiredSfixed64 = requiredSfixed64;
    builder.optionalBool = optionalBool;
    builder.requiredBool = requiredBool;
    builder.optionalString = optionalString;
    builder.requiredString = requiredString;
    builder.optionalBytes = optionalBytes;
    builder.requiredBytes = requiredBytes;
    builder.corpus = corpus;
    builder.samples = Internal.copyOf(samples);
    builder.map = Internal.copyOf(map);
    builder.map_field = Internal.copyOf(map_field);
    builder.details = Internal.copyOf(details);
    builder.name = name;
    builder.nested = nested;
    builder.addUnknownFields(unknownFields());
    return builder;
  }

  @Override
  public boolean equals(Object other) {
    if (other == this) return true;
    if (!(other instanceof TestService3Request)) return false;
    TestService3Request o = (TestService3Request) other;
    return unknownFields().equals(o.unknownFields())
        && Internal.equals(optionalDouble, o.optionalDouble)
        && Internal.equals(requiredDouble, o.requiredDouble)
        && Internal.equals(optionalInt32, o.optionalInt32)
        && Internal.equals(requiredInt32, o.requiredInt32)
        && Internal.equals(optionalInt64, o.optionalInt64)
        && Internal.equals(requiredInt64, o.requiredInt64)
        && Internal.equals(optionalUint32, o.optionalUint32)
        && Internal.equals(requiredUint32, o.requiredUint32)
        && Internal.equals(optionalUint64, o.optionalUint64)
        && Internal.equals(requiredUint64, o.requiredUint64)
        && Internal.equals(optionalSint32, o.optionalSint32)
        && Internal.equals(requiredSint32, o.requiredSint32)
        && Internal.equals(optionalSint64, o.optionalSint64)
        && Internal.equals(requiredSint64, o.requiredSint64)
        && Internal.equals(optionalFixed32, o.optionalFixed32)
        && Internal.equals(requiredFixed32, o.requiredFixed32)
        && Internal.equals(optionalFixed64, o.optionalFixed64)
        && Internal.equals(requiredFixed64, o.requiredFixed64)
        && Internal.equals(optionalSfixed32, o.optionalSfixed32)
        && Internal.equals(requiredSfixed32, o.requiredSfixed32)
        && Internal.equals(optionalSfixed64, o.optionalSfixed64)
        && Internal.equals(requiredSfixed64, o.requiredSfixed64)
        && Internal.equals(optionalBool, o.optionalBool)
        && Internal.equals(requiredBool, o.requiredBool)
        && Internal.equals(optionalString, o.optionalString)
        && Internal.equals(requiredString, o.requiredString)
        && Internal.equals(optionalBytes, o.optionalBytes)
        && Internal.equals(requiredBytes, o.requiredBytes)
        && Internal.equals(corpus, o.corpus)
        && samples.equals(o.samples)
        && map.equals(o.map)
        && map_field.equals(o.map_field)
        && details.equals(o.details)
        && Internal.equals(name, o.name)
        && Internal.equals(nested, o.nested);
  }

  @Override
  public int hashCode() {
    int result = super.hashCode;
    if (result == 0) {
      result = unknownFields().hashCode();
      result = result * 37 + (optionalDouble != null ? optionalDouble.hashCode() : 0);
      result = result * 37 + Double.hashCode(requiredDouble);
      result = result * 37 + (optionalInt32 != null ? optionalInt32.hashCode() : 0);
      result = result * 37 + Integer.hashCode(requiredInt32);
      result = result * 37 + (optionalInt64 != null ? optionalInt64.hashCode() : 0);
      result = result * 37 + Long.hashCode(requiredInt64);
      result = result * 37 + (optionalUint32 != null ? optionalUint32.hashCode() : 0);
      result = result * 37 + Integer.hashCode(requiredUint32);
      result = result * 37 + (optionalUint64 != null ? optionalUint64.hashCode() : 0);
      result = result * 37 + Long.hashCode(requiredUint64);
      result = result * 37 + (optionalSint32 != null ? optionalSint32.hashCode() : 0);
      result = result * 37 + Integer.hashCode(requiredSint32);
      result = result * 37 + (optionalSint64 != null ? optionalSint64.hashCode() : 0);
      result = result * 37 + Long.hashCode(requiredSint64);
      result = result * 37 + (optionalFixed32 != null ? optionalFixed32.hashCode() : 0);
      result = result * 37 + Integer.hashCode(requiredFixed32);
      result = result * 37 + (optionalFixed64 != null ? optionalFixed64.hashCode() : 0);
      result = result * 37 + Long.hashCode(requiredFixed64);
      result = result * 37 + (optionalSfixed32 != null ? optionalSfixed32.hashCode() : 0);
      result = result * 37 + Integer.hashCode(requiredSfixed32);
      result = result * 37 + (optionalSfixed64 != null ? optionalSfixed64.hashCode() : 0);
      result = result * 37 + Long.hashCode(requiredSfixed64);
      result = result * 37 + (optionalBool != null ? optionalBool.hashCode() : 0);
      result = result * 37 + Boolean.hashCode(requiredBool);
      result = result * 37 + (optionalString != null ? optionalString.hashCode() : 0);
      result = result * 37 + (requiredString != null ? requiredString.hashCode() : 0);
      result = result * 37 + (optionalBytes != null ? optionalBytes.hashCode() : 0);
      result = result * 37 + (requiredBytes != null ? requiredBytes.hashCode() : 0);
      result = result * 37 + (corpus != null ? corpus.hashCode() : 0);
      result = result * 37 + samples.hashCode();
      result = result * 37 + map.hashCode();
      result = result * 37 + map_field.hashCode();
      result = result * 37 + details.hashCode();
      result = result * 37 + (name != null ? name.hashCode() : 0);
      result = result * 37 + (nested != null ? nested.hashCode() : 0);
      super.hashCode = result;
    }
    return result;
  }

  @Override
  public String toString() {
    StringBuilder builder = new StringBuilder();
    if (optionalDouble != null) builder.append(", optionalDouble=").append(optionalDouble);
    builder.append(", requiredDouble=").append(requiredDouble);
    if (optionalInt32 != null) builder.append(", optionalInt32=").append(optionalInt32);
    builder.append(", requiredInt32=").append(requiredInt32);
    if (optionalInt64 != null) builder.append(", optionalInt64=").append(optionalInt64);
    builder.append(", requiredInt64=").append(requiredInt64);
    if (optionalUint32 != null) builder.append(", optionalUint32=").append(optionalUint32);
    builder.append(", requiredUint32=").append(requiredUint32);
    if (optionalUint64 != null) builder.append(", optionalUint64=").append(optionalUint64);
    builder.append(", requiredUint64=").append(requiredUint64);
    if (optionalSint32 != null) builder.append(", optionalSint32=").append(optionalSint32);
    builder.append(", requiredSint32=").append(requiredSint32);
    if (optionalSint64 != null) builder.append(", optionalSint64=").append(optionalSint64);
    builder.append(", requiredSint64=").append(requiredSint64);
    if (optionalFixed32 != null) builder.append(", optionalFixed32=").append(optionalFixed32);
    builder.append(", requiredFixed32=").append(requiredFixed32);
    if (optionalFixed64 != null) builder.append(", optionalFixed64=").append(optionalFixed64);
    builder.append(", requiredFixed64=").append(requiredFixed64);
    if (optionalSfixed32 != null) builder.append(", optionalSfixed32=").append(optionalSfixed32);
    builder.append(", requiredSfixed32=").append(requiredSfixed32);
    if (optionalSfixed64 != null) builder.append(", optionalSfixed64=").append(optionalSfixed64);
    builder.append(", requiredSfixed64=").append(requiredSfixed64);
    if (optionalBool != null) builder.append(", optionalBool=").append(optionalBool);
    builder.append(", requiredBool=").append(requiredBool);
    if (optionalString != null) builder.append(", optionalString=").append(Internal.sanitize(optionalString));
    if (requiredString != null) builder.append(", requiredString=").append(Internal.sanitize(requiredString));
    if (optionalBytes != null) builder.append(", optionalBytes=").append(optionalBytes);
    if (requiredBytes != null) builder.append(", requiredBytes=").append(requiredBytes);
    if (corpus != null) builder.append(", corpus=").append(corpus);
    if (!samples.isEmpty()) builder.append(", samples=").append(samples);
    if (!map.isEmpty()) builder.append(", map=").append(map);
    if (!map_field.isEmpty()) builder.append(", map_field=").append(map_field);
    if (!details.isEmpty()) builder.append(", details=").append(details);
    if (name != null) builder.append(", name=").append(Internal.sanitize(name));
    if (nested != null) builder.append(", nested=").append(nested);
    return builder.replace(0, 2, "TestService3Request{").append('}').toString();
  }

  public static final class Builder extends Message.Builder<TestService3Request, Builder> {
    public Double optionalDouble;

    public double requiredDouble;

    public Integer optionalInt32;

    public int requiredInt32;

    public Long optionalInt64;

    public long requiredInt64;

    public Integer optionalUint32;

    public int requiredUint32;

    public Long optionalUint64;

    public long requiredUint64;

    public Integer optionalSint32;

    public int requiredSint32;

    public Long optionalSint64;

    public long requiredSint64;

    public Integer optionalFixed32;

    public int requiredFixed32;

    public Long optionalFixed64;

    public long requiredFixed64;

    public Integer optionalSfixed32;

    public int requiredSfixed32;

    public Long optionalSfixed64;

    public long requiredSfixed64;

    public Boolean optionalBool;

    public boolean requiredBool;

    public String optionalString;

    public String requiredString;

    public ByteString optionalBytes;

    public ByteString requiredBytes;

    public Corpus corpus;

    public List<Integer> samples;

    public Map<String, NestedMessage> map;

    public List<MapFieldEntry> map_field;

    public List<AnyMessage> details;

    public String name;

    public NestedMessage nested;

    public Builder() {
      requiredDouble = 0.0;
      requiredInt32 = 0;
      requiredInt64 = 0L;
      requiredUint32 = 0;
      requiredUint64 = 0L;
      requiredSint32 = 0;
      requiredSint64 = 0L;
      requiredFixed32 = 0;
      requiredFixed64 = 0L;
      requiredSfixed32 = 0;
      requiredSfixed64 = 0L;
      requiredBool = false;
      requiredString = "";
      requiredBytes = ByteString.EMPTY;
      samples = Internal.newMutableList();
      map = Internal.newMutableMap();
      map_field = Internal.newMutableList();
      details = Internal.newMutableList();
    }

    /**
     *  Extensions not supported in proto3
     *  https://developers.google.com/protocol-buffers/docs/proto#extensions
     *  https://developers.google.com/protocol-buffers/docs/proto#choosing
     *  extensions 100 to 199, 1000 to max;
     *  https://developers.google.com/protocol-buffers/docs/proto#specifying-rules
     *  https://developers.google.com/protocol-buffers/docs/proto#scalar
     */
    public Builder optionalDouble(Double optionalDouble) {
      this.optionalDouble = optionalDouble;
      return this;
    }

    public Builder requiredDouble(double requiredDouble) {
      this.requiredDouble = requiredDouble;
      return this;
    }

    public Builder optionalInt32(Integer optionalInt32) {
      this.optionalInt32 = optionalInt32;
      return this;
    }

    public Builder requiredInt32(int requiredInt32) {
      this.requiredInt32 = requiredInt32;
      return this;
    }

    public Builder optionalInt64(Long optionalInt64) {
      this.optionalInt64 = optionalInt64;
      return this;
    }

    public Builder requiredInt64(long requiredInt64) {
      this.requiredInt64 = requiredInt64;
      return this;
    }

    public Builder optionalUint32(Integer optionalUint32) {
      this.optionalUint32 = optionalUint32;
      return this;
    }

    public Builder requiredUint32(int requiredUint32) {
      this.requiredUint32 = requiredUint32;
      return this;
    }

    public Builder optionalUint64(Long optionalUint64) {
      this.optionalUint64 = optionalUint64;
      return this;
    }

    public Builder requiredUint64(long requiredUint64) {
      this.requiredUint64 = requiredUint64;
      return this;
    }

    public Builder optionalSint32(Integer optionalSint32) {
      this.optionalSint32 = optionalSint32;
      return this;
    }

    public Builder requiredSint32(int requiredSint32) {
      this.requiredSint32 = requiredSint32;
      return this;
    }

    public Builder optionalSint64(Long optionalSint64) {
      this.optionalSint64 = optionalSint64;
      return this;
    }

    public Builder requiredSint64(long requiredSint64) {
      this.requiredSint64 = requiredSint64;
      return this;
    }

    public Builder optionalFixed32(Integer optionalFixed32) {
      this.optionalFixed32 = optionalFixed32;
      return this;
    }

    public Builder requiredFixed32(int requiredFixed32) {
      this.requiredFixed32 = requiredFixed32;
      return this;
    }

    public Builder optionalFixed64(Long optionalFixed64) {
      this.optionalFixed64 = optionalFixed64;
      return this;
    }

    public Builder requiredFixed64(long requiredFixed64) {
      this.requiredFixed64 = requiredFixed64;
      return this;
    }

    public Builder optionalSfixed32(Integer optionalSfixed32) {
      this.optionalSfixed32 = optionalSfixed32;
      return this;
    }

    public Builder requiredSfixed32(int requiredSfixed32) {
      this.requiredSfixed32 = requiredSfixed32;
      return this;
    }

    public Builder optionalSfixed64(Long optionalSfixed64) {
      this.optionalSfixed64 = optionalSfixed64;
      return this;
    }

    public Builder requiredSfixed64(long requiredSfixed64) {
      this.requiredSfixed64 = requiredSfixed64;
      return this;
    }

    public Builder optionalBool(Boolean optionalBool) {
      this.optionalBool = optionalBool;
      return this;
    }

    public Builder requiredBool(boolean requiredBool) {
      this.requiredBool = requiredBool;
      return this;
    }

    public Builder optionalString(String optionalString) {
      this.optionalString = optionalString;
      return this;
    }

    public Builder requiredString(String requiredString) {
      this.requiredString = requiredString;
      return this;
    }

    public Builder optionalBytes(ByteString optionalBytes) {
      this.optionalBytes = optionalBytes;
      return this;
    }

    public Builder requiredBytes(ByteString requiredBytes) {
      this.requiredBytes = requiredBytes;
      return this;
    }

    public Builder corpus(Corpus corpus) {
      this.corpus = corpus;
      return this;
    }

    /**
     *  https://developers.google.com/protocol-buffers/docs/proto#other
     */
    public Builder samples(List<Integer> samples) {
      Internal.checkElementsNotNull(samples);
      this.samples = samples;
      return this;
    }

    /**
     *  https://developers.google.com/protocol-buffers/docs/proto#maps (MAps can't have lables)
     */
    public Builder map(Map<String, NestedMessage> map) {
      Internal.checkElementsNotNull(map);
      this.map = map;
      return this;
    }

    public Builder map_field(List<MapFieldEntry> map_field) {
      Internal.checkElementsNotNull(map_field);
      this.map_field = map_field;
      return this;
    }

    /**
     * https://developers.google.com/protocol-buffers/docs/proto3#any (Support to any)
     */
    public Builder details(List<AnyMessage> details) {
      Internal.checkElementsNotNull(details);
      this.details = details;
      return this;
    }

    public Builder name(String name) {
      this.name = name;
      this.nested = null;
      return this;
    }

    public Builder nested(NestedMessage nested) {
      this.nested = nested;
      this.name = null;
      return this;
    }

    @Override
    public TestService3Request build() {
      return new TestService3Request(this, super.buildUnknownFields());
    }
  }

  /**
   * Defaults not supported in proto3 (https://developers.google.com/protocol-buffers/docs/proto3#default)
   *  optional int32 optionalWithDefaultInt32 = 34 [default = 10];
   *  optional string optionalWithDefaultString = 35 [default = "temp_holder"];
   *  https://developers.google.com/protocol-buffers/docs/proto#enum
   */
  public enum Corpus implements WireEnum {
    UNIVERSAL(0),

    WEB(1),

    IMAGES(2),

    LOCAL(3),

    NEWS(4),

    PRODUCTS(5),

    VIDEO(6);

    public static final ProtoAdapter<Corpus> ADAPTER = new ProtoAdapter_Corpus();

    private final int value;

    Corpus(int value) {
      this.value = value;
    }

    /**
     * Return the constant for {@code value} or null.
     */
    public static Corpus fromValue(int value) {
      switch (value) {
        case 0: return UNIVERSAL;
        case 1: return WEB;
        case 2: return IMAGES;
        case 3: return LOCAL;
        case 4: return NEWS;
        case 5: return PRODUCTS;
        case 6: return VIDEO;
        default: return null;
      }
    }

    @Override
    public int getValue() {
      return value;
    }

    private static final class ProtoAdapter_Corpus extends EnumAdapter<Corpus> {
      ProtoAdapter_Corpus() {
        super(Corpus.class, Syntax.PROTO_3, Corpus.UNIVERSAL);
      }

      @Override
      protected Corpus fromValue(int value) {
        return Corpus.fromValue(value);
      }
    }
  }

  /**
   *  [default = UNIVERSAL];
   */
  public enum EnumAllowingAlias implements WireEnum {
    UNKNOWN(0),

    STARTED(1),

    RUNNING(1);

    public static final ProtoAdapter<EnumAllowingAlias> ADAPTER = new ProtoAdapter_EnumAllowingAlias();

    private final int value;

    EnumAllowingAlias(int value) {
      this.value = value;
    }

    /**
     * Return the constant for {@code value} or null.
     */
    public static EnumAllowingAlias fromValue(int value) {
      switch (value) {
        case 0: return UNKNOWN;
        case 1: return STARTED;
        default: return null;
      }
    }

    @Override
    public int getValue() {
      return value;
    }

    private static final class ProtoAdapter_EnumAllowingAlias extends EnumAdapter<EnumAllowingAlias> {
      ProtoAdapter_EnumAllowingAlias() {
        super(EnumAllowingAlias.class, Syntax.PROTO_3, EnumAllowingAlias.UNKNOWN);
      }

      @Override
      protected EnumAllowingAlias fromValue(int value) {
        return EnumAllowingAlias.fromValue(value);
      }
    }
  }

  /**
   * https://developers.google.com/protocol-buffers/docs/proto#nested
   */
  public static final class NestedMessage extends Message<NestedMessage, NestedMessage.Builder> {
    public static final ProtoAdapter<NestedMessage> ADAPTER = new ProtoAdapter_NestedMessage();

    private static final long serialVersionUID = 0L;

    public static final String DEFAULT_TITLE = "";

    @WireField(
        tag = 1,
        adapter = "com.squareup.wire.ProtoAdapter#STRING",
        label = WireField.Label.OMIT_IDENTITY
    )
    public final String url;

    @WireField(
        tag = 2,
        adapter = "com.squareup.wire.ProtoAdapter#STRING"
    )
    public final String title;

    @WireField(
        tag = 3,
        adapter = "com.squareup.wire.ProtoAdapter#STRING",
        label = WireField.Label.REPEATED
    )
    public final List<String> snippets;

    public NestedMessage(String url, String title, List<String> snippets) {
      this(url, title, snippets, ByteString.EMPTY);
    }

    public NestedMessage(String url, String title, List<String> snippets,
        ByteString unknownFields) {
      super(ADAPTER, unknownFields);
      if (url == null) {
        throw new IllegalArgumentException("url == null");
      }
      this.url = url;
      this.title = title;
      this.snippets = Internal.immutableCopyOf("snippets", snippets);
    }

    @Override
    public Builder newBuilder() {
      Builder builder = new Builder();
      builder.url = url;
      builder.title = title;
      builder.snippets = Internal.copyOf(snippets);
      builder.addUnknownFields(unknownFields());
      return builder;
    }

    @Override
    public boolean equals(Object other) {
      if (other == this) return true;
      if (!(other instanceof NestedMessage)) return false;
      NestedMessage o = (NestedMessage) other;
      return unknownFields().equals(o.unknownFields())
          && Internal.equals(url, o.url)
          && Internal.equals(title, o.title)
          && snippets.equals(o.snippets);
    }

    @Override
    public int hashCode() {
      int result = super.hashCode;
      if (result == 0) {
        result = unknownFields().hashCode();
        result = result * 37 + (url != null ? url.hashCode() : 0);
        result = result * 37 + (title != null ? title.hashCode() : 0);
        result = result * 37 + snippets.hashCode();
        super.hashCode = result;
      }
      return result;
    }

    @Override
    public String toString() {
      StringBuilder builder = new StringBuilder();
      if (url != null) builder.append(", url=").append(Internal.sanitize(url));
      if (title != null) builder.append(", title=").append(Internal.sanitize(title));
      if (!snippets.isEmpty()) builder.append(", snippets=").append(Internal.sanitize(snippets));
      return builder.replace(0, 2, "NestedMessage{").append('}').toString();
    }

    public static final class Builder extends Message.Builder<NestedMessage, Builder> {
      public String url;

      public String title;

      public List<String> snippets;

      public Builder() {
        url = "";
        snippets = Internal.newMutableList();
      }

      public Builder url(String url) {
        this.url = url;
        return this;
      }

      public Builder title(String title) {
        this.title = title;
        return this;
      }

      public Builder snippets(List<String> snippets) {
        Internal.checkElementsNotNull(snippets);
        this.snippets = snippets;
        return this;
      }

      @Override
      public NestedMessage build() {
        return new NestedMessage(url, title, snippets, super.buildUnknownFields());
      }
    }

    private static final class ProtoAdapter_NestedMessage extends ProtoAdapter<NestedMessage> {
      public ProtoAdapter_NestedMessage() {
        super(FieldEncoding.LENGTH_DELIMITED, NestedMessage.class, "type.googleapis.com/test3.TestService3Request.NestedMessage", Syntax.PROTO_3, null, "test3.proto");
      }

      @Override
      public int encodedSize(NestedMessage value) {
        int result = 0;
        if (!Objects.equals(value.url, "")) {
          result += ProtoAdapter.STRING.encodedSizeWithTag(1, value.url);
        }
        result += ProtoAdapter.STRING.encodedSizeWithTag(2, value.title);
        result += ProtoAdapter.STRING.asRepeated().encodedSizeWithTag(3, value.snippets);
        result += value.unknownFields().size();
        return result;
      }

      @Override
      public void encode(ProtoWriter writer, NestedMessage value) throws IOException {
        if (!Objects.equals(value.url, "")) ProtoAdapter.STRING.encodeWithTag(writer, 1, value.url);
        ProtoAdapter.STRING.encodeWithTag(writer, 2, value.title);
        ProtoAdapter.STRING.asRepeated().encodeWithTag(writer, 3, value.snippets);
        writer.writeBytes(value.unknownFields());
      }

      @Override
      public void encode(ReverseProtoWriter writer, NestedMessage value) throws IOException {
        writer.writeBytes(value.unknownFields());
        ProtoAdapter.STRING.asRepeated().encodeWithTag(writer, 3, value.snippets);
        ProtoAdapter.STRING.encodeWithTag(writer, 2, value.title);
        if (!Objects.equals(value.url, "")) ProtoAdapter.STRING.encodeWithTag(writer, 1, value.url);
      }

      @Override
      public NestedMessage decode(ProtoReader reader) throws IOException {
        Builder builder = new Builder();
        long token = reader.beginMessage();
        for (int tag; (tag = reader.nextTag()) != -1;) {
          switch (tag) {
            case 1: builder.url(ProtoAdapter.STRING.decode(reader)); break;
            case 2: builder.title(ProtoAdapter.STRING.decode(reader)); break;
            case 3: builder.snippets.add(ProtoAdapter.STRING.decode(reader)); break;
            default: {
              reader.readUnknownField(tag);
            }
          }
        }
        builder.addUnknownFields(reader.endMessageAndGetUnknownFields(token));
        return builder.build();
      }

      @Override
      public NestedMessage redact(NestedMessage value) {
        Builder builder = value.newBuilder();
        builder.clearUnknownFields();
        return builder.build();
      }
    }
  }

  /**
   * Map equivalent wire type (Backward compatibility) https://developers.google.com/protocol-buffers/docs/proto#backwards
   */
  public static final class MapFieldEntry extends Message<MapFieldEntry, MapFieldEntry.Builder> {
    public static final ProtoAdapter<MapFieldEntry> ADAPTER = new ProtoAdapter_MapFieldEntry();

    private static final long serialVersionUID = 0L;

    @WireField(
        tag = 1,
        adapter = "com.squareup.wire.ProtoAdapter#STRING",
        label = WireField.Label.OMIT_IDENTITY
    )
    public final String key;

    @WireField(
        tag = 2,
        adapter = "com.proto.test3.TestService3Request$NestedMessage#ADAPTER",
        label = WireField.Label.OMIT_IDENTITY
    )
    public final NestedMessage value;

    public MapFieldEntry(String key, NestedMessage value) {
      this(key, value, ByteString.EMPTY);
    }

    public MapFieldEntry(String key, NestedMessage value, ByteString unknownFields) {
      super(ADAPTER, unknownFields);
      if (key == null) {
        throw new IllegalArgumentException("key == null");
      }
      this.key = key;
      this.value = value;
    }

    @Override
    public Builder newBuilder() {
      Builder builder = new Builder();
      builder.key = key;
      builder.value = value;
      builder.addUnknownFields(unknownFields());
      return builder;
    }

    @Override
    public boolean equals(Object other) {
      if (other == this) return true;
      if (!(other instanceof MapFieldEntry)) return false;
      MapFieldEntry o = (MapFieldEntry) other;
      return unknownFields().equals(o.unknownFields())
          && Internal.equals(key, o.key)
          && Internal.equals(value, o.value);
    }

    @Override
    public int hashCode() {
      int result = super.hashCode;
      if (result == 0) {
        result = unknownFields().hashCode();
        result = result * 37 + (key != null ? key.hashCode() : 0);
        result = result * 37 + (value != null ? value.hashCode() : 0);
        super.hashCode = result;
      }
      return result;
    }

    @Override
    public String toString() {
      StringBuilder builder = new StringBuilder();
      if (key != null) builder.append(", key=").append(Internal.sanitize(key));
      if (value != null) builder.append(", value=").append(value);
      return builder.replace(0, 2, "MapFieldEntry{").append('}').toString();
    }

    public static final class Builder extends Message.Builder<MapFieldEntry, Builder> {
      public String key;

      public NestedMessage value;

      public Builder() {
        key = "";
      }

      public Builder key(String key) {
        this.key = key;
        return this;
      }

      public Builder value(NestedMessage value) {
        this.value = value;
        return this;
      }

      @Override
      public MapFieldEntry build() {
        return new MapFieldEntry(key, value, super.buildUnknownFields());
      }
    }

    private static final class ProtoAdapter_MapFieldEntry extends ProtoAdapter<MapFieldEntry> {
      public ProtoAdapter_MapFieldEntry() {
        super(FieldEncoding.LENGTH_DELIMITED, MapFieldEntry.class, "type.googleapis.com/test3.TestService3Request.MapFieldEntry", Syntax.PROTO_3, null, "test3.proto");
      }

      @Override
      public int encodedSize(MapFieldEntry value) {
        int result = 0;
        if (!Objects.equals(value.key, "")) {
          result += ProtoAdapter.STRING.encodedSizeWithTag(1, value.key);
        }
        if (!Objects.equals(value.value, null)) {
          result += NestedMessage.ADAPTER.encodedSizeWithTag(2, value.value);
        }
        result += value.unknownFields().size();
        return result;
      }

      @Override
      public void encode(ProtoWriter writer, MapFieldEntry value) throws IOException {
        if (!Objects.equals(value.key, "")) ProtoAdapter.STRING.encodeWithTag(writer, 1, value.key);
        if (!Objects.equals(value.value, null)) NestedMessage.ADAPTER.encodeWithTag(writer, 2, value.value);
        writer.writeBytes(value.unknownFields());
      }

      @Override
      public void encode(ReverseProtoWriter writer, MapFieldEntry value) throws IOException {
        writer.writeBytes(value.unknownFields());
        if (!Objects.equals(value.value, null)) NestedMessage.ADAPTER.encodeWithTag(writer, 2, value.value);
        if (!Objects.equals(value.key, "")) ProtoAdapter.STRING.encodeWithTag(writer, 1, value.key);
      }

      @Override
      public MapFieldEntry decode(ProtoReader reader) throws IOException {
        Builder builder = new Builder();
        long token = reader.beginMessage();
        for (int tag; (tag = reader.nextTag()) != -1;) {
          switch (tag) {
            case 1: builder.key(ProtoAdapter.STRING.decode(reader)); break;
            case 2: builder.value(NestedMessage.ADAPTER.decode(reader)); break;
            default: {
              reader.readUnknownField(tag);
            }
          }
        }
        builder.addUnknownFields(reader.endMessageAndGetUnknownFields(token));
        return builder.build();
      }

      @Override
      public MapFieldEntry redact(MapFieldEntry value) {
        Builder builder = value.newBuilder();
        if (builder.value != null) builder.value = NestedMessage.ADAPTER.redact(builder.value);
        builder.clearUnknownFields();
        return builder.build();
      }
    }
  }

  private static final class ProtoAdapter_TestService3Request extends ProtoAdapter<TestService3Request> {
    private ProtoAdapter<Map<String, NestedMessage>> map;

    public ProtoAdapter_TestService3Request() {
      super(FieldEncoding.LENGTH_DELIMITED, TestService3Request.class, "type.googleapis.com/test3.TestService3Request", Syntax.PROTO_3, null, "test3.proto");
    }

    @Override
    public int encodedSize(TestService3Request value) {
      int result = 0;
      result += ProtoAdapter.DOUBLE.encodedSizeWithTag(1, value.optionalDouble);
      if (!Objects.equals(value.requiredDouble, 0.0)) {
        result += ProtoAdapter.DOUBLE.encodedSizeWithTag(3, value.requiredDouble);
      }
      result += ProtoAdapter.INT32.encodedSizeWithTag(4, value.optionalInt32);
      if (!Objects.equals(value.requiredInt32, 0)) {
        result += ProtoAdapter.INT32.encodedSizeWithTag(5, value.requiredInt32);
      }
      result += ProtoAdapter.INT64.encodedSizeWithTag(6, value.optionalInt64);
      if (!Objects.equals(value.requiredInt64, 0L)) {
        result += ProtoAdapter.INT64.encodedSizeWithTag(7, value.requiredInt64);
      }
      result += ProtoAdapter.UINT32.encodedSizeWithTag(8, value.optionalUint32);
      if (!Objects.equals(value.requiredUint32, 0)) {
        result += ProtoAdapter.UINT32.encodedSizeWithTag(12, value.requiredUint32);
      }
      result += ProtoAdapter.UINT64.encodedSizeWithTag(13, value.optionalUint64);
      if (!Objects.equals(value.requiredUint64, 0L)) {
        result += ProtoAdapter.UINT64.encodedSizeWithTag(14, value.requiredUint64);
      }
      result += ProtoAdapter.SINT32.encodedSizeWithTag(16, value.optionalSint32);
      if (!Objects.equals(value.requiredSint32, 0)) {
        result += ProtoAdapter.SINT32.encodedSizeWithTag(17, value.requiredSint32);
      }
      result += ProtoAdapter.SINT64.encodedSizeWithTag(18, value.optionalSint64);
      if (!Objects.equals(value.requiredSint64, 0L)) {
        result += ProtoAdapter.SINT64.encodedSizeWithTag(19, value.requiredSint64);
      }
      result += ProtoAdapter.FIXED32.encodedSizeWithTag(20, value.optionalFixed32);
      if (!Objects.equals(value.requiredFixed32, 0)) {
        result += ProtoAdapter.FIXED32.encodedSizeWithTag(21, value.requiredFixed32);
      }
      result += ProtoAdapter.FIXED64.encodedSizeWithTag(22, value.optionalFixed64);
      if (!Objects.equals(value.requiredFixed64, 0L)) {
        result += ProtoAdapter.FIXED64.encodedSizeWithTag(23, value.requiredFixed64);
      }
      result += ProtoAdapter.SFIXED32.encodedSizeWithTag(24, value.optionalSfixed32);
      if (!Objects.equals(value.requiredSfixed32, 0)) {
        result += ProtoAdapter.SFIXED32.encodedSizeWithTag(25, value.requiredSfixed32);
      }
      result += ProtoAdapter.SFIXED64.encodedSizeWithTag(26, value.optionalSfixed64);
      if (!Objects.equals(value.requiredSfixed64, 0L)) {
        result += ProtoAdapter.SFIXED64.encodedSizeWithTag(27, value.requiredSfixed64);
      }
      result += ProtoAdapter.BOOL.encodedSizeWithTag(28, value.optionalBool);
      if (!Objects.equals(value.requiredBool, false)) {
        result += ProtoAdapter.BOOL.encodedSizeWithTag(29, value.requiredBool);
      }
      result += ProtoAdapter.STRING.encodedSizeWithTag(30, value.optionalString);
      if (!Objects.equals(value.requiredString, "")) {
        result += ProtoAdapter.STRING.encodedSizeWithTag(31, value.requiredString);
      }
      result += ProtoAdapter.BYTES.encodedSizeWithTag(32, value.optionalBytes);
      if (!Objects.equals(value.requiredBytes, ByteString.EMPTY)) {
        result += ProtoAdapter.BYTES.encodedSizeWithTag(33, value.requiredBytes);
      }
      result += Corpus.ADAPTER.encodedSizeWithTag(36, value.corpus);
      result += ProtoAdapter.INT32.asPacked().encodedSizeWithTag(37, value.samples);
      result += mapAdapter().encodedSizeWithTag(40, value.map);
      result += MapFieldEntry.ADAPTER.asRepeated().encodedSizeWithTag(41, value.map_field);
      result += AnyMessage.ADAPTER.asRepeated().encodedSizeWithTag(42, value.details);
      result += ProtoAdapter.STRING.encodedSizeWithTag(38, value.name);
      result += NestedMessage.ADAPTER.encodedSizeWithTag(39, value.nested);
      result += value.unknownFields().size();
      return result;
    }

    @Override
    public void encode(ProtoWriter writer, TestService3Request value) throws IOException {
      ProtoAdapter.DOUBLE.encodeWithTag(writer, 1, value.optionalDouble);
      if (!Objects.equals(value.requiredDouble, 0.0)) ProtoAdapter.DOUBLE.encodeWithTag(writer, 3, value.requiredDouble);
      ProtoAdapter.INT32.encodeWithTag(writer, 4, value.optionalInt32);
      if (!Objects.equals(value.requiredInt32, 0)) ProtoAdapter.INT32.encodeWithTag(writer, 5, value.requiredInt32);
      ProtoAdapter.INT64.encodeWithTag(writer, 6, value.optionalInt64);
      if (!Objects.equals(value.requiredInt64, 0L)) ProtoAdapter.INT64.encodeWithTag(writer, 7, value.requiredInt64);
      ProtoAdapter.UINT32.encodeWithTag(writer, 8, value.optionalUint32);
      if (!Objects.equals(value.requiredUint32, 0)) ProtoAdapter.UINT32.encodeWithTag(writer, 12, value.requiredUint32);
      ProtoAdapter.UINT64.encodeWithTag(writer, 13, value.optionalUint64);
      if (!Objects.equals(value.requiredUint64, 0L)) ProtoAdapter.UINT64.encodeWithTag(writer, 14, value.requiredUint64);
      ProtoAdapter.SINT32.encodeWithTag(writer, 16, value.optionalSint32);
      if (!Objects.equals(value.requiredSint32, 0)) ProtoAdapter.SINT32.encodeWithTag(writer, 17, value.requiredSint32);
      ProtoAdapter.SINT64.encodeWithTag(writer, 18, value.optionalSint64);
      if (!Objects.equals(value.requiredSint64, 0L)) ProtoAdapter.SINT64.encodeWithTag(writer, 19, value.requiredSint64);
      ProtoAdapter.FIXED32.encodeWithTag(writer, 20, value.optionalFixed32);
      if (!Objects.equals(value.requiredFixed32, 0)) ProtoAdapter.FIXED32.encodeWithTag(writer, 21, value.requiredFixed32);
      ProtoAdapter.FIXED64.encodeWithTag(writer, 22, value.optionalFixed64);
      if (!Objects.equals(value.requiredFixed64, 0L)) ProtoAdapter.FIXED64.encodeWithTag(writer, 23, value.requiredFixed64);
      ProtoAdapter.SFIXED32.encodeWithTag(writer, 24, value.optionalSfixed32);
      if (!Objects.equals(value.requiredSfixed32, 0)) ProtoAdapter.SFIXED32.encodeWithTag(writer, 25, value.requiredSfixed32);
      ProtoAdapter.SFIXED64.encodeWithTag(writer, 26, value.optionalSfixed64);
      if (!Objects.equals(value.requiredSfixed64, 0L)) ProtoAdapter.SFIXED64.encodeWithTag(writer, 27, value.requiredSfixed64);
      ProtoAdapter.BOOL.encodeWithTag(writer, 28, value.optionalBool);
      if (!Objects.equals(value.requiredBool, false)) ProtoAdapter.BOOL.encodeWithTag(writer, 29, value.requiredBool);
      ProtoAdapter.STRING.encodeWithTag(writer, 30, value.optionalString);
      if (!Objects.equals(value.requiredString, "")) ProtoAdapter.STRING.encodeWithTag(writer, 31, value.requiredString);
      ProtoAdapter.BYTES.encodeWithTag(writer, 32, value.optionalBytes);
      if (!Objects.equals(value.requiredBytes, ByteString.EMPTY)) ProtoAdapter.BYTES.encodeWithTag(writer, 33, value.requiredBytes);
      Corpus.ADAPTER.encodeWithTag(writer, 36, value.corpus);
      ProtoAdapter.INT32.asPacked().encodeWithTag(writer, 37, value.samples);
      mapAdapter().encodeWithTag(writer, 40, value.map);
      MapFieldEntry.ADAPTER.asRepeated().encodeWithTag(writer, 41, value.map_field);
      AnyMessage.ADAPTER.asRepeated().encodeWithTag(writer, 42, value.details);
      ProtoAdapter.STRING.encodeWithTag(writer, 38, value.name);
      NestedMessage.ADAPTER.encodeWithTag(writer, 39, value.nested);
      writer.writeBytes(value.unknownFields());
    }

    @Override
    public void encode(ReverseProtoWriter writer, TestService3Request value) throws IOException {
      writer.writeBytes(value.unknownFields());
      NestedMessage.ADAPTER.encodeWithTag(writer, 39, value.nested);
      ProtoAdapter.STRING.encodeWithTag(writer, 38, value.name);
      AnyMessage.ADAPTER.asRepeated().encodeWithTag(writer, 42, value.details);
      MapFieldEntry.ADAPTER.asRepeated().encodeWithTag(writer, 41, value.map_field);
      mapAdapter().encodeWithTag(writer, 40, value.map);
      ProtoAdapter.INT32.asPacked().encodeWithTag(writer, 37, value.samples);
      Corpus.ADAPTER.encodeWithTag(writer, 36, value.corpus);
      if (!Objects.equals(value.requiredBytes, ByteString.EMPTY)) ProtoAdapter.BYTES.encodeWithTag(writer, 33, value.requiredBytes);
      ProtoAdapter.BYTES.encodeWithTag(writer, 32, value.optionalBytes);
      if (!Objects.equals(value.requiredString, "")) ProtoAdapter.STRING.encodeWithTag(writer, 31, value.requiredString);
      ProtoAdapter.STRING.encodeWithTag(writer, 30, value.optionalString);
      if (!Objects.equals(value.requiredBool, false)) ProtoAdapter.BOOL.encodeWithTag(writer, 29, value.requiredBool);
      ProtoAdapter.BOOL.encodeWithTag(writer, 28, value.optionalBool);
      if (!Objects.equals(value.requiredSfixed64, 0L)) ProtoAdapter.SFIXED64.encodeWithTag(writer, 27, value.requiredSfixed64);
      ProtoAdapter.SFIXED64.encodeWithTag(writer, 26, value.optionalSfixed64);
      if (!Objects.equals(value.requiredSfixed32, 0)) ProtoAdapter.SFIXED32.encodeWithTag(writer, 25, value.requiredSfixed32);
      ProtoAdapter.SFIXED32.encodeWithTag(writer, 24, value.optionalSfixed32);
      if (!Objects.equals(value.requiredFixed64, 0L)) ProtoAdapter.FIXED64.encodeWithTag(writer, 23, value.requiredFixed64);
      ProtoAdapter.FIXED64.encodeWithTag(writer, 22, value.optionalFixed64);
      if (!Objects.equals(value.requiredFixed32, 0)) ProtoAdapter.FIXED32.encodeWithTag(writer, 21, value.requiredFixed32);
      ProtoAdapter.FIXED32.encodeWithTag(writer, 20, value.optionalFixed32);
      if (!Objects.equals(value.requiredSint64, 0L)) ProtoAdapter.SINT64.encodeWithTag(writer, 19, value.requiredSint64);
      ProtoAdapter.SINT64.encodeWithTag(writer, 18, value.optionalSint64);
      if (!Objects.equals(value.requiredSint32, 0)) ProtoAdapter.SINT32.encodeWithTag(writer, 17, value.requiredSint32);
      ProtoAdapter.SINT32.encodeWithTag(writer, 16, value.optionalSint32);
      if (!Objects.equals(value.requiredUint64, 0L)) ProtoAdapter.UINT64.encodeWithTag(writer, 14, value.requiredUint64);
      ProtoAdapter.UINT64.encodeWithTag(writer, 13, value.optionalUint64);
      if (!Objects.equals(value.requiredUint32, 0)) ProtoAdapter.UINT32.encodeWithTag(writer, 12, value.requiredUint32);
      ProtoAdapter.UINT32.encodeWithTag(writer, 8, value.optionalUint32);
      if (!Objects.equals(value.requiredInt64, 0L)) ProtoAdapter.INT64.encodeWithTag(writer, 7, value.requiredInt64);
      ProtoAdapter.INT64.encodeWithTag(writer, 6, value.optionalInt64);
      if (!Objects.equals(value.requiredInt32, 0)) ProtoAdapter.INT32.encodeWithTag(writer, 5, value.requiredInt32);
      ProtoAdapter.INT32.encodeWithTag(writer, 4, value.optionalInt32);
      if (!Objects.equals(value.requiredDouble, 0.0)) ProtoAdapter.DOUBLE.encodeWithTag(writer, 3, value.requiredDouble);
      ProtoAdapter.DOUBLE.encodeWithTag(writer, 1, value.optionalDouble);
    }

    @Override
    public TestService3Request decode(ProtoReader reader) throws IOException {
      Builder builder = new Builder();
      long token = reader.beginMessage();
      for (int tag; (tag = reader.nextTag()) != -1;) {
        switch (tag) {
          case 1: builder.optionalDouble(ProtoAdapter.DOUBLE.decode(reader)); break;
          case 3: builder.requiredDouble(ProtoAdapter.DOUBLE.decode(reader)); break;
          case 4: builder.optionalInt32(ProtoAdapter.INT32.decode(reader)); break;
          case 5: builder.requiredInt32(ProtoAdapter.INT32.decode(reader)); break;
          case 6: builder.optionalInt64(ProtoAdapter.INT64.decode(reader)); break;
          case 7: builder.requiredInt64(ProtoAdapter.INT64.decode(reader)); break;
          case 8: builder.optionalUint32(ProtoAdapter.UINT32.decode(reader)); break;
          case 12: builder.requiredUint32(ProtoAdapter.UINT32.decode(reader)); break;
          case 13: builder.optionalUint64(ProtoAdapter.UINT64.decode(reader)); break;
          case 14: builder.requiredUint64(ProtoAdapter.UINT64.decode(reader)); break;
          case 16: builder.optionalSint32(ProtoAdapter.SINT32.decode(reader)); break;
          case 17: builder.requiredSint32(ProtoAdapter.SINT32.decode(reader)); break;
          case 18: builder.optionalSint64(ProtoAdapter.SINT64.decode(reader)); break;
          case 19: builder.requiredSint64(ProtoAdapter.SINT64.decode(reader)); break;
          case 20: builder.optionalFixed32(ProtoAdapter.FIXED32.decode(reader)); break;
          case 21: builder.requiredFixed32(ProtoAdapter.FIXED32.decode(reader)); break;
          case 22: builder.optionalFixed64(ProtoAdapter.FIXED64.decode(reader)); break;
          case 23: builder.requiredFixed64(ProtoAdapter.FIXED64.decode(reader)); break;
          case 24: builder.optionalSfixed32(ProtoAdapter.SFIXED32.decode(reader)); break;
          case 25: builder.requiredSfixed32(ProtoAdapter.SFIXED32.decode(reader)); break;
          case 26: builder.optionalSfixed64(ProtoAdapter.SFIXED64.decode(reader)); break;
          case 27: builder.requiredSfixed64(ProtoAdapter.SFIXED64.decode(reader)); break;
          case 28: builder.optionalBool(ProtoAdapter.BOOL.decode(reader)); break;
          case 29: builder.requiredBool(ProtoAdapter.BOOL.decode(reader)); break;
          case 30: builder.optionalString(ProtoAdapter.STRING.decode(reader)); break;
          case 31: builder.requiredString(ProtoAdapter.STRING.decode(reader)); break;
          case 32: builder.optionalBytes(ProtoAdapter.BYTES.decode(reader)); break;
          case 33: builder.requiredBytes(ProtoAdapter.BYTES.decode(reader)); break;
          case 36: {
            try {
              builder.corpus(Corpus.ADAPTER.decode(reader));
            } catch (ProtoAdapter.EnumConstantNotFoundException e) {
              builder.addUnknownField(tag, FieldEncoding.VARINT, (long) e.value);
            }
            break;
          }
          case 37: builder.samples.add(ProtoAdapter.INT32.decode(reader)); break;
          case 38: builder.name(ProtoAdapter.STRING.decode(reader)); break;
          case 39: builder.nested(NestedMessage.ADAPTER.decode(reader)); break;
          case 40: builder.map.putAll(mapAdapter().decode(reader)); break;
          case 41: builder.map_field.add(MapFieldEntry.ADAPTER.decode(reader)); break;
          case 42: builder.details.add(AnyMessage.ADAPTER.decode(reader)); break;
          default: {
            reader.readUnknownField(tag);
          }
        }
      }
      builder.addUnknownFields(reader.endMessageAndGetUnknownFields(token));
      return builder.build();
    }

    @Override
    public TestService3Request redact(TestService3Request value) {
      Builder builder = value.newBuilder();
      Internal.redactElements(builder.map, NestedMessage.ADAPTER);
      Internal.redactElements(builder.map_field, MapFieldEntry.ADAPTER);
      Internal.redactElements(builder.details, AnyMessage.ADAPTER);
      if (builder.nested != null) builder.nested = NestedMessage.ADAPTER.redact(builder.nested);
      builder.clearUnknownFields();
      return builder.build();
    }

    private ProtoAdapter<Map<String, NestedMessage>> mapAdapter() {
      ProtoAdapter<Map<String, NestedMessage>> result = map;
      if (result == null) {
        result = ProtoAdapter.newMapAdapter(ProtoAdapter.STRING, NestedMessage.ADAPTER);
        map = result;
      }
      return result;
    }
  }
}
